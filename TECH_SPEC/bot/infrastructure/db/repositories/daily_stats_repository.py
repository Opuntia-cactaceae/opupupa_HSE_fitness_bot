from datetime import date
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select

from domain.entities.daily_stats import DailyStats
from domain.interfaces.daily_stats_repository import DailyStatsRepository
from infrastructure.db.models import DailyStatsModel


def to_domain(model: DailyStatsModel) -> DailyStats:
    return DailyStats(
        id=model.id,
        user_id=model.user_id,
        date=model.date,
        temperature_c=model.temperature_c,
        water_goal_ml=model.water_goal_ml,
        calorie_goal_kcal=model.calorie_goal_kcal,
        water_logged_ml=model.water_logged_ml,
        calories_consumed_kcal=model.calories_consumed_kcal,
        calories_burned_kcal=model.calories_burned_kcal,
        created_at=model.created_at,
        updated_at=model.updated_at,
    )


def to_model(stats: DailyStats) -> DailyStatsModel:
    return DailyStatsModel(
        id=stats.id,
        user_id=stats.user_id,
        date=stats.date,
        temperature_c=stats.temperature_c,
        water_goal_ml=stats.water_goal_ml,
        calorie_goal_kcal=stats.calorie_goal_kcal,
        water_logged_ml=stats.water_logged_ml,
        calories_consumed_kcal=stats.calories_consumed_kcal,
        calories_burned_kcal=stats.calories_burned_kcal,
        created_at=stats.created_at,
        updated_at=stats.updated_at,
    )


class DailyStatsRepositoryImpl(DailyStatsRepository):
    def __init__(self, session: AsyncSession):
        self._session = session

    async def add(self, daily_stats: DailyStats) -> None:
        model = to_model(daily_stats)
        self._session.add(model)

    async def get(self, user_id: int, date: date) -> DailyStats | None:
        stmt = select(DailyStatsModel).where(
            DailyStatsModel.user_id == user_id, DailyStatsModel.date == date
        )
        result = await self._session.execute(stmt)
        model = result.scalar_one_or_none()
        return to_domain(model) if model else None

    async def update(self, daily_stats: DailyStats) -> None:
        stmt = select(DailyStatsModel).where(DailyStatsModel.id == daily_stats.id)
        result = await self._session.execute(stmt)
        model = result.scalar_one()
        model.temperature_c = daily_stats.temperature_c
        model.water_goal_ml = daily_stats.water_goal_ml
        model.calorie_goal_kcal = daily_stats.calorie_goal_kcal
        model.water_logged_ml = daily_stats.water_logged_ml
        model.calories_consumed_kcal = daily_stats.calories_consumed_kcal
        model.calories_burned_kcal = daily_stats.calories_burned_kcal
        model.updated_at = daily_stats.updated_at

    async def delete(self, daily_stats_id: int) -> None:
        stmt = select(DailyStatsModel).where(DailyStatsModel.id == daily_stats_id)
        result = await self._session.execute(stmt)
        model = result.scalar_one_or_none()
        if model:
            await self._session.delete(model)

    async def get_or_create(self, user_id: int, date: date) -> DailyStats:
        existing = await self.get(user_id, date)
        if existing:
            return existing
        from datetime import datetime
        new_stats = DailyStats(
            id=0,  # temporary, will be generated by DB
            user_id=user_id,
            date=date,
            created_at=datetime.utcnow(),
            updated_at=datetime.utcnow(),
        )
        await self.add(new_stats)
        await self._session.flush()  # to get generated ID
        # need to refresh to get the generated id
        stmt = select(DailyStatsModel).where(
            DailyStatsModel.user_id == user_id, DailyStatsModel.date == date
        )
        result = await self._session.execute(stmt)
        model = result.scalar_one()
        return to_domain(model)